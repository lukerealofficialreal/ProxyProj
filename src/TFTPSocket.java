//Note: As they are not relevant to this project, this implementation does not support write requests

//server sends illegal operation to client
//Client receives null somehow
//index out of bounds in sliding window setState after (failed?) setAbsolutePosition

import java.io.IOException;
import java.net.*;
import java.util.*;

import static java.util.Map.entry;


public class TFTPSocket implements AutoCloseable {

    private static final int DEFAULT_WINDOW_SIZE = 8;

    //In miliseconds
    private static final int DEFAULT_TIMEOUT = 5500;

    private static final short NO_BLOCK_NUM = -1;

    //In nanoseconds
    private  static final long WAIT_BEFORE_RESEND = 1000000000L; //2000 miliseconds
    private  static final long WAIT_BEFORE_TERMINATE = WAIT_BEFORE_RESEND*3;
    /*Error Codes

Implemented    Value     Meaning

               0         Not defined, see error message (if any).
     X         1         File not found.
     X         2         Access violation.
               3         Disk full or allocation exceeded.
     X         4         Illegal TFTP operation.
               5         Unknown transfer ID.
               6         File already exists.
               7         No such user.
     X         8         Invalid Options.
     */
    private final TFTPErrorPacket FILE_NOT_FOUND = new TFTPErrorPacket(TFTPPacket.Opcode.ERROR, (short)1, "File not found.");
    private final TFTPErrorPacket ACCESS_VIOLATION = new TFTPErrorPacket(TFTPPacket.Opcode.ERROR, (short)2, "Access violation");
    private final TFTPErrorPacket ILLEGAL_OPERATION = new TFTPErrorPacket(TFTPPacket.Opcode.ERROR, (short)4, "Illegal TFTP operation.");
    private final TFTPErrorPacket INVALID_OPTIONS = new TFTPErrorPacket(TFTPPacket.Opcode.ERROR, (short)8, "Invalid Options.");

    //Custom error packet, generated by the client after not receiving a response before a timeout
    private final TFTPErrorPacket TIME_OUT_ERROR = new TFTPErrorPacket(TFTPPacket.Opcode.ERROR, (short)0, "Socket Timeout.");

    /*Options

    Key         Value     Meaning

    senderId    Long      The ID of the initiator of the transaction (the client)
    encryptKey  Long      The key to be used for encryption. If this option exists, encryption becomes enabled implicitly
    windowSize  Integer   The maximum number of sequential packets to be sent before an ack is received. Default is DEFAULT_RECEIVE_WINDOW_SIZE
    timeOut     Integer   The maximum amount of time permitted between received packets before the transaction is cancelled
    tsize       Long      The size of the file. Because the value is not known to the sender of a write request, this value
                                is sent as 0 and OACKed as the correct value
     */
    //Perhaps it would be better to have different categories of options
    //One "public" category of options which the user may want to change (i.e. windowSize)
    //and another "private" category of options which the user can never change (i.e. tsize)
    public static final List<String> supportedOptions = List.of("senderId","encryptKey","windowSize","timeOut","tsize", "drops");
    public static final HashMap<String, String> DEFAULT_OPTIONS = new HashMap<>(Map.ofEntries(
            entry("senderId", String.valueOf((new Random()).nextLong())),
            entry("encryptKey", String.valueOf((new Random()).nextLong())),
            entry("windowSize", String.valueOf(DEFAULT_WINDOW_SIZE)),
            entry("timeOut", String.valueOf(DEFAULT_TIMEOUT)),
            entry("drops", "0"),
            entry("tsize", "0")));

    private final Encryption encryption = new XOREncryption(); //Encryption scheme

    private Long userId = new Random().nextLong(Long.MAX_VALUE);
    private Long recipientId; //The user id received by the user. Only serve this user until the transaction is completed

    private TFTPErrorPacket lastError = null;

    private int windowSize = DEFAULT_WINDOW_SIZE;
    private Integer fileSize = null;

    private SlidingWindow<TFTPPacket> sendWindow; //= new SlidingWindow<>();
    private ArrayList<TFTPPacket> receiveList; //

    private DatagramSocket datagramSocket;

    private boolean receiveOpen = false;

    private InetAddress lastClientAddr = null;
    private int lastClientPort = -1;

    int totalDataReceived = 0;

    int dropChance = 0;

    Stopwatch timer = new Stopwatch();

    public TFTPSocket(int port) throws IOException {
        datagramSocket = new DatagramSocket(port);
        datagramSocket.setSoTimeout(DEFAULT_TIMEOUT);
    }

    public TFTPSocket(int port, InetAddress address) throws IOException {
        datagramSocket = new DatagramSocket(port, address);
        datagramSocket.setSoTimeout(DEFAULT_TIMEOUT);
    }

    //takes a hashmap of options and their respective values and applies each option
    private void enableOptions(HashMap<String, String> options) {
        try {
            this.recipientId = stringToLongOrNull(options.get("senderId"));

            this.encryption.setKey(stringToLongOrNull(options.get("encryptKey")));

            Long newWindowSize = stringToLongOrNull(options.get("windowSize"));
            this.windowSize = (newWindowSize != null) ? newWindowSize.intValue() : windowSize;

            Long timeOut = stringToLongOrNull(options.get("timeOut"));
            this.datagramSocket.setSoTimeout((timeOut != null) ? timeOut.intValue() : datagramSocket.getSoTimeout());


            Long fsize = stringToLongOrNull(options.get("tsize"));
            this.fileSize =(fsize != null) ? fsize.intValue() : null;
            if(fileSize == null) {
                throw new TFTPException(INVALID_OPTIONS);
            }
            Long newDropChance = stringToLongOrNull(options.get("drops"));
            this.dropChance = (newDropChance != null) ? newDropChance.intValue() : this.dropChance;

            if(dropChance > 0) {
                assert newWindowSize != null;
                timer = new Stopwatch("_windowSize" + newWindowSize.toString() + "_drops");
            } else {
                assert newWindowSize != null;
                timer = new Stopwatch("_windowSize" + newWindowSize.toString() + "_noDrops");
            }

        } catch (NumberFormatException e) {
            throw new TFTPException(INVALID_OPTIONS);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private boolean verifyOptions(HashMap<String, String> sent, HashMap<String, String> oack) {
        //1. If the oack contains any options not sent, invalid
        if(!sent.keySet().containsAll(oack.keySet())) {
            return false;
        }

        //2. If options contained:
        //      senderId, encryptKey, windowSize
        //   they must contain the same values
        if(!(sent.get("senderId").equals(oack.get("senderId"))) ||
                !(sent.get("encryptKey").equals(oack.get("encryptKey"))) ||
                !(sent.get("windowSize").equals(oack.get("windowSize")))) {
            return false;
        }

        //3. If options contained:
        //      tsize
        //  ensure oack contained tsize
        if((sent.get("tsize") == null)^(oack.get("tsize") == null)) {
            return false;
        }

        //4. A timeout must be set
        try {
            if (oack.get("timeOut") == null || Integer.parseInt(oack.get("timeOut")) <= 0) {
                return false;
            }
        } catch(NumberFormatException e) {
            return false;
        }
        return true;
    }

    //prepares buffers using the current window size
    private void prepareReceiveBuffer() {
        receiveList = new ArrayList<>(windowSize);
    }
    private void prepareSendWindow(byte[] initData) {

        //break data into many packets
        TFTPDataPacket[] dataPackets = new TFTPDataPacket[(initData.length/TFTPDataPacket.MAX_DATA_SIZE) + 1];

        for(int i = 0; i < dataPackets.length; i++) {
            int currPos = i*TFTPDataPacket.MAX_DATA_SIZE;
            //When the distance between the current pos in the data and the length of the remaining data is less than
            //the max size of a data packet, use it instead
            int copyAmt = Math.min((initData.length - currPos), TFTPDataPacket.MAX_DATA_SIZE);
            byte[] buffer = new byte[copyAmt];
            System.arraycopy(initData, currPos, buffer, 0, copyAmt);
            dataPackets[i] = new TFTPDataPacket(TFTPPacket.Opcode.DATA, buffer, (short)(i));
        }

        sendWindow = new SlidingWindow<>(dataPackets, windowSize);
    }

    //Sends read request to bound socket
    //If request is successful, a read will be initiated.
    //If the read is successfully completed, the read data will be returned.
    //Else, returns null
    //
    //If the error is recoverable, attempts to recover.
    public byte[] read(Request request) throws WrongRequestTypeException, IOException, TFTPException {

        //timer.enable();

        //1. Prepare read request
        //      convert request into TFTPReadWritePacket
        if(request.type != Request.RequestType.READ) {
            throw new WrongRequestTypeException(request.type.name(), Request.RequestType.READ.name());
        }

        //Force the tsize value to allow the fileSize to be determined later
        request.options.put("tsize","0");

        TFTPReadWritePacket requestPacket = requestToPacket(request);

        //2. Put read request into a datagram packet and send
        send(requestPacket, request.getAddress(), request.getPort());

        //4. receive OACK (Data packet if the server did not accept the appended options, or if no options were appended)

        TFTPPacket receive = receive();
        switch(receive.opcode) {
            //At least one of the options were accepted. Determine if all options were accepted, and only continue if so
            case OACK:
                TFTPOptionPacket opt = (TFTPOptionPacket)receive;
                if(verifyOptions(requestPacket.getOptions().getMap(), opt.getMap())) {
                    //Enable all the options and continue
                    enableOptions(opt.getMap());
                    send(new TFTPAckPacket(TFTPPacket.Opcode.ACK, (short)0), request.getAddress(), request.getPort());

                    totalDataReceived = Integer.parseInt(opt.getMap().get("tsize"));
                } else {
                    send(INVALID_OPTIONS, request.getAddress(), request.getPort());
                    throw new TFTPException(INVALID_OPTIONS);
                }
                break;

            //No options were accepted. Determine if no options were sent and continue if so.
            //Else send an error and throw exception
            case DATA:
                if(request.options == null) {
                    send(INVALID_OPTIONS, request.getAddress(), request.getPort());
                    throw new TFTPException(INVALID_OPTIONS);
                }
                break;

            //Something went wrong. Throw an exception based on this error
            case ERROR:
                throw new TFTPException((TFTPErrorPacket)receive);

            //No other opcode is valid. Send invalid Opcode error and throw exception
            default:
                send(ILLEGAL_OPERATION, request.getAddress(), request.getPort());
                throw new TFTPException(ILLEGAL_OPERATION);

        }

        //Allocate receive buffer and begin receiving and acknowledging
        prepareReceiveBuffer();
        boolean dataRemaining = true;
        Long currBlockNum = (long)0;

        /* already acked the oack
        //Add initial received packet to buffer
        receiveList.add(receive);
        */

        //enable encryption
        encryption.enable();

        //Activate constant receives

        receiveOpen = true;
        Thread receiveLoop = new Thread(() -> {
            while(receiveOpen) {
                    try {
                        TFTPPacket newPacket = receive();
                        synchronized (this) {
                            receiveList.add(newPacket);
                        }
                        //System.out.println(receiveList);
                    } catch (IOException e) {
                        break;
                    }

            }
            return;
        });
        receiveLoop.start();

        //Define variable sized array to store data
        byte[] data = new byte[fileSize];
        int dataLoc = 0;

        //Begin processing and sending acks
        while(dataRemaining) {
            //Get first packet from buffer
            synchronized (this) {
                try {
                    receive = receiveList.get(0);
                } catch (IndexOutOfBoundsException e) {
                    //busy wait until packet is received
                    continue;
                }
            }

            if(receive == null) {
                synchronized (this) {
                    try {
                        receiveList.remove(0);
                    } catch (IndexOutOfBoundsException e) {
                        //Should never occur
                        receiveOpen = false;
                        throw new RuntimeException(e);
                    }
                }
                continue;
            }

            //Take action on the packet depending on what packet was received
            switch(receive.opcode) {
                //No options were accepted. Determine if no options were sent and continue if so.
                //Else send an error and throw exception
                case DATA:
                    TFTPDataPacket dataPacket = (TFTPDataPacket) receive;

                    //if the packet is a duplicate, print
                    //if(dataPacket.getBlockNum() < currBlockNum) {
                    //    System.out.println("Duplicate packet '" + dataPacket.getBlockNum() + "'");
                    //}

                    //Get block number, verify that it is the next packet in the sequence.
                    if(dataPacket.getBlockNum() <= currBlockNum) {
                        send(acknowledgeDataPacket(dataPacket), request.getAddress(), request.getPort());

                    } else {
                        //Packets dropped or out of order, throw away the packet queue

                            //It is questionable if this is the right call here
                            //
                            //receiveList.clear();
                            System.out.println("Packet '"  + dataPacket.getBlockNum() +"' dropped or out of order (expected " + currBlockNum + ")");
                            //continue;
                            break;

                    }

                    if(dataPacket.getBlockNum() == currBlockNum) {
                        currBlockNum++;
                        byte[] localData = dataPacket.getData();
                        System.arraycopy(localData,0, data, dataLoc, localData.length);
                        dataLoc += localData.length;

                        //the last packet will have less than the maximum size
                        if(dataPacket.size < TFTPPacket.MAX_PACKET_SIZE) {
                            dataRemaining = false;
                        }
                    }

                    //If there is a duplicate packet, currBlockNum is not incremented and the packet is removed.

                    break;

                //If oackack was not received previously, ack it again
                case OACK:
                    send(new TFTPAckPacket(TFTPPacket.Opcode.ACK, (short)0), request.getAddress(), request.getPort());
                    break;

                //Something went wrong. Throw an exception based on this error
                case ERROR:
                    //If timeout, ignore it and busy wait.
                    if(receive == TIME_OUT_ERROR) {
                        //System.out.println("Timeout ignored");
                        break;
                    }
                    receiveOpen = false;
                    throw new TFTPException((TFTPErrorPacket)receive);


                //No other opcode is valid. Send invalid Opcode error and throw exception
                default:
                    send(ILLEGAL_OPERATION, request.getAddress(), request.getPort());
                    receiveOpen = false;
                    throw new TFTPException(ILLEGAL_OPERATION);
            }
            synchronized (this) {
                try {
                    //This predicate should always evaluate to true. For some unknown reason, it is possible for receiveList
                    //System.out.println(((TFTPDataPacket)receiveList.get(0)).getBlockNum() == ((TFTPDataPacket)receive).getBlockNum());
                    ////if(receiveList.size() == 0) {
                   //     System.out.println("FUCK");
                    //}

                    receiveList.remove(0);
                } catch (IndexOutOfBoundsException e) {
                    //Should never occur
                    receiveOpen = false;
                    throw new RuntimeException(e);
                }
            }
            System.out.println("reading: " + Integer.toString(dataLoc) + "/" + Integer.toString(totalDataReceived));
        }
        receiveOpen = false;
        return data;
    }

    public void denyReadRequest() throws IOException {
        send(FILE_NOT_FOUND, lastClientAddr, lastClientPort);
    }

    public void serveReadRequest(byte[] data, HashMap<String, String> options) throws IOException {
        //prepare the oack to be sent back

        //if the options contains tsize, update them with the correct value of tsize
        if(options.get("tsize") != null) {
            options.put("tsize", String.valueOf(data.length));
        }

        //Ensure all options are supported
        Set<String> sentOptions = options.keySet();
        if(!(new HashSet<>(supportedOptions).containsAll(sentOptions))) {
            send(INVALID_OPTIONS, lastClientAddr, lastClientPort);
            receiveOpen = false;
            throw new TFTPException(INVALID_OPTIONS);
        }

        //Apply options
        enableOptions(options);
        timer.enable();

        //Send OACK repeatedly until acknowledgement
        boolean ackedOack = false;
        TFTPPacket received;
        while(!ackedOack) {
            send(new TFTPOptionPacket(TFTPPacket.Opcode.OACK, options), lastClientAddr, lastClientPort);
            received = receive();

            switch (received.opcode) {
                case ACK:
                    if(((TFTPAckPacket)received).getBlockNum() == 0) {
                        ackedOack = true;
                    }
                    else {
                        send(ILLEGAL_OPERATION, lastClientAddr, lastClientPort);
                        throw new TFTPException(ILLEGAL_OPERATION);
                    }
                    break;
                //Something went wrong. Throw an exception based on this error
                case ERROR:
                    receiveOpen = false;
                    assert received instanceof TFTPErrorPacket;
                    throw new TFTPException((TFTPErrorPacket)received);

                    //No other opcode is valid. Send invalid Opcode error and throw exception
                default:
                    send(ILLEGAL_OPERATION, lastClientAddr, lastClientPort);
                    receiveOpen = false;
                    throw new TFTPException(ILLEGAL_OPERATION);
            }
        }

        //prepare window
        prepareSendWindow(data);

        //prepare list to stores acks
        prepareReceiveBuffer();

        encryption.enable();

        receiveOpen = true;
        //Activate constant receive for acknowledgements
        Thread receiveLoop = new Thread(() -> {
            while(receiveOpen) {
                    try {
                        TFTPPacket newPacket = receive();
                        synchronized (this) {
                            receiveList.add(newPacket);
                        }
                    } catch (IOException e) {
                        break;
                    }

            }
            return;

        });
        receiveLoop.start();

        //Send data, resend window if data not acknowledged
        boolean allAcknowledged = false;
        while(!allAcknowledged) {
            sendWindow.resetPosition();
            //Send all packets in the window
            //Only do if timeout

            boolean timeOut = false;
            while (!sendWindow.isEndOfWindow()) {
                if (sendWindow.getState() != SlidingWindow.AckState.ACKED) {
                    TFTPPacket item = sendWindow.getItem();
                    //if (item == null) {
                    //    System.out.println("Sending null item.");
                    //}
                    if(item.getOpcode() == TFTPPacket.Opcode.DATA) {
                        Long lifeTime = null;

                        lifeTime = timer.getTimeSinceStored(((TFTPDataPacket) item).getBlockNum());
                        if (lifeTime != null && WAIT_BEFORE_TERMINATE < lifeTime) {
                            return; //timeout
                        }

                        //If an item was sent but the time returned null, something is wrong. Break;
                        if(!timeOut && lifeTime == null && sendWindow.getState() == SlidingWindow.AckState.SENT)
                            break;

                        //Once the timeout occurs or the first not sent packet is found, send it and all packets after it
                        timeOut = timeOut || (lifeTime == null || WAIT_BEFORE_RESEND < lifeTime);
                        if (timeOut) {
                            send(sendWindow.getItem(), lastClientAddr, lastClientPort);
                            sendWindow.setState(SlidingWindow.AckState.SENT);
                        }
                    } else {
                        send(sendWindow.getItem(), lastClientAddr, lastClientPort);
                        sendWindow.setState(SlidingWindow.AckState.SENT);
                    }
                }
                sendWindow.nextPosition();
            }


            //Get first packet from buffer if it exists
            while(!receiveList.isEmpty()) {
                TFTPPacket receive;
                synchronized (this) {
                    receive = receiveList.get(0);
                }

                if(receive == null) {
                    synchronized (this) {
                        try {
                            receiveList.remove(0);
                        } catch (IndexOutOfBoundsException e) {
                            //Should never occur
                            receiveOpen = false;
                            throw new RuntimeException(e);
                        }
                    }
                    continue;
                }

                //Take action on the packet depending on what packet was received
                switch (receive.opcode) {
                    case ACK:
                        TFTPAckPacket ackPacket = (TFTPAckPacket) receive;

                        if(ackPacket.getBlockNum() < sendWindow.getLeftBound()){
                            synchronized (this) {
                                try {
                                    receiveList.remove(0);
                                } catch (IndexOutOfBoundsException e) {
                                    //Should never occur
                                    receiveOpen = false;
                                    throw new RuntimeException(e);
                                }
                            }
                            continue;
                        }

                        //Set the packet to Acked
                        sendWindow.setAbsolutePosition(ackPacket.getBlockNum());
                        sendWindow.setState(SlidingWindow.AckState.ACKED);
                        synchronized (this) {
                            try {
                                receiveList.remove(0);
                            } catch (IndexOutOfBoundsException e) {
                                //Should never occur
                                receiveOpen = false;
                                throw new RuntimeException(e);
                            }
                        }

                        //Find the first position with the state SENT and move boundaries such that it is the first item
                        int advance = sendWindow.findFirstState(SlidingWindow.AckState.SENT);

                        //Everything must have already been sent or there's a BIG problem
                        //assert(sendWindow.findFirstState(SlidingWindow.AckState.NOT_SENT) == -1);

                        //advance the window if it moved

                        if(advance != sendWindow.getLeftBound())
                        {
                            //If there was no SENT, then the entire Window was acked
                            //Move it by window size instead
                            if(advance == -1) {
                                sendWindow.pushBound(windowSize);
                            }
                            else {
                                sendWindow.pushBoundTo(advance);
                            }

                            //if the window moved, send all the not sent packets immediately
                            /*
                            while(!sendWindow.isEndOfWindow()){
                                if(sendWindow.getState() == SlidingWindow.AckState.NOT_SENT) {
                                    send(sendWindow.getItem(), lastClientAddr, lastClientPort);
                                    sendWindow.setState(SlidingWindow.AckState.SENT);
                                }
                                sendWindow.nextPosition();
                            }
                             */
                        }

                        //Finished sending data
                        if (!sendWindow.isDataRemaining()) {
                            receiveOpen = false;
                            allAcknowledged = true;
                        }
                        break;

                    //Something went wrong. Throw an exception based on this error
                    case ERROR:
                        //If timeout, ignore it and busy wait.
                        if (receive == TIME_OUT_ERROR) {
                            synchronized (this) {
                                try {
                                    receiveList.remove(0);
                                } catch (IndexOutOfBoundsException e) {
                                    //Should never occur
                                    receiveOpen = false;
                                    throw new RuntimeException(e);
                                }
                            }
                            //System.out.println("Timeout ignored");
                            break;
                        }
                        receiveOpen = false;
                        throw new TFTPException((TFTPErrorPacket) receive);

                        //No other opcode is valid. Send invalid Opcode error and throw exception
                    default:
                        send(ILLEGAL_OPERATION, lastClientAddr, lastClientPort);
                        receiveOpen = false;
                        throw new TFTPException(ILLEGAL_OPERATION);
                }
            }

        }
        System.out.println("server terminated connection.");


    }

    //Accepts read request and returns the fileName requested
    public Request acceptReadRequest() throws IOException, TFTPException {
        //This loop exists for the purpose of ignoring the timeout caused by the receive method
        while (true) {
            TFTPPacket receive = receive();
            switch (receive.opcode) {
                case READ_RQ:
                    if(((TFTPReadWritePacket)receive).getOptions() == null)
                        throw new TFTPException(INVALID_OPTIONS);
                    return new Request((TFTPReadWritePacket)receive, lastClientAddr, lastClientPort);

                //Something went wrong. Throw an exception based on this error
                case ERROR:
                    //If timeout, ignore it and busy wait.
                    if (receive == TIME_OUT_ERROR) {
                        //System.out.println("Timeout ignored");
                        continue;
                    }
                    throw new TFTPException(ACCESS_VIOLATION);

                    //No other opcode is valid. Send invalid Opcode error and throw exception
                    //NOTE: If the Server terminates a previous transaction with a client that does not realize the
                    //transaction has been terminated, the previous client will send a packet which will be accepted by
                    //this method, which will likely trigger this exception.
                default:
                    //Ignore clients who send malformed requests
                    //send(ILLEGAL_OPERATION, lastClientAddr, lastClientPort);
                    throw new TFTPException(ILLEGAL_OPERATION);
            }
        }
    }



    private TFTPAckPacket acknowledgeDataPacket(TFTPDataPacket dataPacket) {
        return new TFTPAckPacket(TFTPPacket.Opcode.ACK, dataPacket.getBlockNum());
    }

    private void send(TFTPPacket packet, InetAddress address, int port) throws IOException {
        //Put read request into a datagram packet
        byte[] rawRequest = packet.getRaw();

        //Encrypt
        rawRequest = encryption.encrypt(rawRequest);

        //rawRequest, rawRequest.length,
        DatagramPacket wrappedPacket = new DatagramPacket(rawRequest, rawRequest.length, address, port);

        //Start timer
        short key;
        switch(packet.opcode) {
            case READ_RQ, WRITE_RQ, OACK -> {
                key = NO_BLOCK_NUM;
            }
            case ACK -> {
                key = ((TFTPAckPacket)packet).getBlockNum();
            }
            case DATA -> {
                key = ((TFTPDataPacket)packet).getBlockNum();
                System.out.println("Sending Data packet with block: " + key);
            }
            case ERROR -> {
                datagramSocket.send(wrappedPacket);
                return;
            }
            default -> throw new RuntimeException(); //Should never occur
        }
        timer.start(key);

        //Send read request
        datagramSocket.send(wrappedPacket);
    }

    private TFTPPacket receive() throws IOException {
        byte[] buffer = new byte[TFTPPacket.MAX_PACKET_SIZE];
        try {
            DatagramPacket wrappedPacket = new DatagramPacket(buffer, TFTPPacket.MAX_PACKET_SIZE);
            datagramSocket.receive(wrappedPacket);

            //Roll to drop packet. If dropChance > 0, there is a chance to randomly drop the packet
            if(rollToDrop()) {
                return TIME_OUT_ERROR;
            }

            byte[] rawReceive = Arrays.copyOf(buffer, wrappedPacket.getLength());

            rawReceive = encryption.decrypt(rawReceive);

            lastClientAddr = wrappedPacket.getAddress();
            lastClientPort = wrappedPacket.getPort();

            //System.out.println("length of received response: " + Integer.toString(rawReceive.length));

            //Determine the type of packet received and respond appropriately.
            TFTPPacket.Opcode opcode = TFTPPacket.getOpcodeFromRaw(rawReceive);
            switch(opcode) {
                case READ_RQ, WRITE_RQ -> {
                    TFTPReadWritePacket packet = new TFTPReadWritePacket(rawReceive);
                    timer.stop(NO_BLOCK_NUM, packet.getSize());
                    return packet;
                }
                case DATA -> {
                    TFTPDataPacket packet = new TFTPDataPacket(rawReceive);
                    timer.stop(packet.getBlockNum(), packet.getSize());
                    return packet;
                }
                case ACK -> {
                    TFTPAckPacket packet = new TFTPAckPacket(rawReceive);
                    timer.stop(packet.getBlockNum(), packet.getSize());
                    return packet;
                }
                case ERROR -> {
                    TFTPErrorPacket packet = new TFTPErrorPacket(rawReceive);
                    //no timer
                    return packet;
                }
                case OACK -> {
                    TFTPOptionPacket packet = new TFTPOptionPacket(rawReceive);
                    timer.stop(NO_BLOCK_NUM, packet.getSize());
                    return packet;
                }
            }
            throw new TFTPException(ILLEGAL_OPERATION);

        } catch (IndexOutOfBoundsException e) {
            //TODO: catch an indexoutofbounds exception here and send an error. For the purpose of enforcing the 512 size limit
            throw new IndexOutOfBoundsException();
        } catch (SocketTimeoutException e) {
            return TIME_OUT_ERROR;
        }
    }

    //If newWindowSize is not a valid window size, returns false
    //If newWindowSize is a valid window size but the window has not been allocated, sets '
    //      windowSize to newWindowSize and returns true.
    public boolean setReceiveWindowSize(int newWindowSize) {
        if(isValidWindowSize(newWindowSize)) {
            this.windowSize = newWindowSize;
            return true;
        }
        return false;
    }

    public int getWindowSize() { return windowSize; }

    //Convert request instance into request packet
    private TFTPReadWritePacket requestToPacket(Request request) {
        TFTPPacket.Opcode opcode = (request.type == Request.RequestType.READ) ?
                TFTPPacket.Opcode.READ_RQ :  TFTPPacket.Opcode.WRITE_RQ;

        TFTPOptionPacket options = new TFTPOptionPacket(opcode, request.options);

        return new TFTPReadWritePacket(opcode, request.fname, options);
    }
    public int getPort() {return datagramSocket.getPort();}
    public SocketAddress getAddress() {return datagramSocket.getLocalSocketAddress();}
    public void bind(SocketAddress address) throws SocketException {datagramSocket.bind(address);}

    private boolean isValidWindowSize(int testWindowSize) {
        return (testWindowSize > 0);

    }

    public void close() {
        datagramSocket.close();
        System.out.println("Socket closed!");
    }

    public int getLocalPort() {
        return datagramSocket.getLocalPort();
    }

    public void setDropChance(int dropChance) {
        if(dropChance > 100)
            this.dropChance = 100;
        else if(dropChance < 0)
            this.dropChance = 0;
        else
            this.dropChance = dropChance;
    }
    private boolean rollToDrop() {
        Random random = new Random();
        int randomNumber = random.nextInt(0, 101); // Generates a number between 0 (inclusive) and 101 (exclusive)
        return dropChance > randomNumber;
    }

    public static Long stringToLongOrNull(String str) {
        if (str == null || str.isEmpty()) {
            return null;
        }
        try {
            return Long.parseLong(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }
}
